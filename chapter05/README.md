## 5.7 정리: 연관관계 매핑의 핵심

### 기본 원칙

*   단방향 매핑만으로도 테이블과 객체의 연관관계 매핑은 이미 완료된 상태이다.
*   단방향 관계를 양방향으로 만드는 것은, 단순히 반대 방향으로 객체 그래프를 탐색하는 기능을 추가하는 것이다.
*   양방향 연관관계를 매핑하려면, 애플리케이션 로직에서 객체의 양쪽 방향 관계를 모두 관리해주어야 한다.

> 양방향 매핑은 복잡성을 증가시킬 수 있다. 비즈니스 로직상 꼭 필요한 경우가 아니라면, **우선 단방향 매핑으로 시작**하고 나중에 반대 방향 탐색 기능(`JPQL` 쿼리 포함)이 필요해질 때 양방향으로 확장하는 것을 권장한다.

<br>

> ### 연관관계의 주인을 정하는 기준
>
> 양방향 관계에서 '연관관계의 주인'을 정하는 기준 때문에 혼동이 생길 수 있다. **비즈니스 로직상의 중요도**로 주인을 선택해서는 절대 안 된다.
>
> 연관관계의 주인은 비즈니스 중요도와 무관하며, 단순히 **'외래 키(FK)를 관리하는 자'** 라는 기술적인 의미만 부여해야 한다.
>
> *   **예시 1) `회원`과 `팀`**: 외래 키는 다(N) 쪽인 `회원` 테이블에 있으므로, **`회원` 엔티티가 연관관계의 주인**이 된다. (비즈니스적으로 `팀`이 더 중요해 보일지라도)
> *   **예시 2) `자동차`와 `바퀴`**: 외래 키는 다(N) 쪽인 `바퀴`에 있으므로, **`바퀴`가 연관관계의 주인**이 된다. (`자동차` 본체가 훨씬 중요해 보이지만, 기준은 오직 외래 키의 위치이다.)
>
> > **결론: 연관관계의 주인은 외래 키의 위치를 기준으로 정해야 하며, 비즈니스 중요도로 접근하면 안 된다!**

<br>

> ### 양방향 매핑 시 무한 루프 주의
>
> 양방향 연관관계에서는 **무한 루프**에 빠지지 않도록 각별히 주의해야 한다.
>
> 예를 들어, `Member.toString()`에서 `getTeam()`을 호출하고, 다시 `Team.toString()`에서 `getMembers()`를 호출하면 서로를 계속 호출하며 무한 루프에 빠져 `StackOverflowError`가 발생할 수 있다.
>
> *   이런 문제는 엔티티를 **`JSON`으로 변환**할 때 자주 발생한다. 대부분의 `JSON` 라이브러리는 `@JsonIgnore` 같은 어노테이션으로 순환 참조를 방지하는 기능을 제공한다.
> *   `Lombok`의 `@ToString` 어노테이션을 사용할 때도 흔히 발생하므로, `@ToString(exclude = "team")`과 같이 연관관계 필드를 제외하는 옵션을 반드시 사용해야 한다.

<br>

> ### 참고: 일대다(1:N) 관계에서 '일(1)'을 주인으로 삼는 경우
>
> 기술적으로 일대다 관계에서 '일(1)' 쪽(예: `Team` 엔티티의 `Team.members` 필드)을 연관관계의 주인으로 설정하는 것이 불가능하지는 않다.
>
> 하지만 이 방식은 연관관계가 없는 다른 테이블의 외래 키를 관리하게 되므로, 추가적인 업데이트 쿼리가 발생하는 등 **성능과 유지보수 측면에서 단점이 많아 권장하지 않는다.**
>
> **항상 외래 키가 있는 곳을 연관관계의 주인으로 선택하는 것이 가장 좋다.**