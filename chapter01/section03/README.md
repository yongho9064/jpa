# 1.3 JPA란 무엇인가?

JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준이다. 아래 그림과 같이 애플리케이션과 JDBC 사이에서 동작한다.

> **그림 1.6 JPA 아키텍처**
>
> ![JPA Architecture](https://user-images.githubusercontent.com/13410737/209441426-bff0d8a4-ca75-4e99-bc6c-11fc1aa8fb5a.png)

그렇다면 ORM이란 무엇일까? ORM(Object-Relational Mapping)은 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다. ORM 프레임워크는 객체와 테이블을 매핑해서 **패러다임의 불일치 문제**를 개발자 대신 해결해준다.

JPA를 사용해서 객체를 저장하는 것은 매우 간단하다.

> **그림 1.7 JPA 저장**
>
> ![JPA Save Operation](https://user-images.githubusercontent.com/13410737/209441903-529569af-8516-4e21-9d80-654ab26b0994.png)

JPA를 사용해서 객체를 저장하는 코드는 다음과 같다.

```java
jpa.persist(member); // 저장
```

조회할 때도 JPA를 통해 객체를 직접 조회하면 된다.

> **그림 1.8 JPA 조회**
>
> ![JPA Find Operation](https://user-images.githubusercontent.com/13410737/209441825-02ab6353-180e-43d6-a15b-37c3657e67a4.png)

JPA를 사용해서 객체를 조회하는 코드는 다음과 같다.

```java
Member member = jpa.find(memberId); // 조회
```

ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라, 앞서 이야기한 다양한 패러다임의 불일치 문제들도 해결해준다.

따라서 객체 측면에서는 정교한 객체 모델링을 할 수 있고, 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다. 그리고 이 둘을 어떻게 매핑할지 방법만 ORM 프레임워크에 알려주면 된다.

덕분에 개발자는 데이터 중심인 관계형 데이터베이스를 사용해도 **객체지향 애플리케이션 개발에 집중**할 수 있다.

## 1.3.1 JPA 소개

과거 자바 진영은 엔터프라이즈 자바 빈즈(EJB)라는 기술 표준을 만들었는데, 그 안에는 엔티티 빈이라는 ORM 기술도 포함되어 있었다. 하지만 너무 복잡하고 기술 성숙도도 떨어졌으며 자바 엔터프라이즈 애플리케이션 서버에서만 동작하는 단점이 있었다.

이때 **하이버네이트(Hibernate)**라는 오픈소스 ORM 프레임워크가 등장했다. EJB의 ORM 기술과 비교해서 가볍고 실용적인 데다 기술 성숙도도 높았으며, 자바 엔터프라이즈 애플리케이션 서버 없이도 동작해서 많은 개발자가 사용하기 시작했다.

결국 EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어졌는데, 이것이 바로 **JPA**다.

> **그림 1.9 JPA 표준 인터페이스와 구현체**
>
> ![JPA Standard and Implementations](https://user-images.githubusercontent.com/13410737/209442407-d5024cce-60c1-4532-a893-28db7649407c.png)

> **JPA는 자바 ORM 기술에 대한 API 표준 명세다.**
> 쉽게 이야기해서 인터페이스를 모아둔 것이다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크(예: 하이버네이트, EclipseLink, DataNucleus)를 선택해야 한다.

JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고, 다른 구현 기술로 손쉽게 이동할 수 있는 장점이 있다. JPA 표준은 일반적이고 공통적인 기능의 모음이므로, 표준을 먼저 이해하고 필요에 따라 JPA 구현체가 제공하는 고유 기능을 알아가는 것이 좋다.

## 1.3.2 왜 JPA를 사용해야 하는가?

#### 1. 생산성
JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다. 지루하고 반복적인 CRUD용 SQL과 JDBC API 코드를 개발자가 직접 작성하지 않아도 된다.
```java
jpa.persist(member);   // 저장
Member member = jpa.find(memberId);  // 조회
```
더 나아가 JPA에는 `CREATE TABLE` 같은 DDL(데이터 정의 언어) 문을 자동으로 생성해주는 기능도 있어, 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

#### 2. 유지보수
기존의 SQL 중심 개발 방식에서는 엔티티에 필드를 하나만 추가해도 관련된 등록, 수정, 조회 SQL과 결과를 매핑하기 위한 JDBC API 코드를 모두 변경해야 했다. 반면에 JPA를 사용하면 이런 과정을 JPA가 대신 처리해주므로 필드를 추가하거나 삭제해도 수정해야 할 코드가 현저히 줄어든다.

#### 3. 패러다임의 불일치 해결
JPA는 객체지향 프로그래밍과 관계형 데이터베이스 간의 근본적인 차이점, 즉 **상속, 연관관계, 객체 그래프 탐색, 비교**와 같은 패러다임의 불일치 문제를 해결해준다. 이를 통해 개발자는 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다.

#### 4. 성능
JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다. 예를 들어, 같은 트랜잭션 안에서 동일한 객체를 여러 번 조회하는 경우, JPA는 첫 조회 시 SQL을 보내고 결과를 캐시에 저장한 뒤, 두 번째 조회부터는 데이터베이스에 접근하지 않고 캐시에서 객체를 반환한다.
```java
// 같은 트랜잭션 내에서
String memberId = "helloId";
Member member1 = jpa.find(memberId); // 1. SELECT SQL 실행
Member member2 = jpa.find(memberId); // 2. SQL 실행 없이 1차 캐시에서 조회
```
이처럼 JPA는 JDBC API를 직접 사용할 때보다 더 효율적인 성능을 낼 수 있는 메커니즘을 갖추고 있다.

#### 5. 데이터 접근 추상화와 벤더 독립성
관계형 데이터베이스는 같은 기능이라도 벤더(Oracle, MySQL, H2 등)마다 SQL 문법이나 사용법이 다른 경우가 많다. 이로 인해 애플리케이션이 특정 데이터베이스 기술에 종속되기 쉽다.

JPA는 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공하여, 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다. 설정 파일에서 데이터베이스 종류만 변경하면, JPA가 해당 데이터베이스에 맞는 SQL을 생성해주므로 손쉽게 데이터베이스를 변경할 수 있다.

> **그림 1.10 벤더 독립성**
>
> ![Vendor Independence through JPA](https://user-images.githubusercontent.com/13410737/209442407-d5024cce-60c1-4532-a893-28db7649407c.png)

#### 6. 표준
JPA는 자바 진영의 ORM 기술 표준이다. 표준을 사용하면 특정 구현체(예: 하이버네이트)에 종속되지 않고, 필요에 따라 다른 구현체로 손쉽게 변경할 수 있는 유연성을 확보할 수 있다.