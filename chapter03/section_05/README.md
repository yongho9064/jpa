## 3.5 플러시 (flush)

**플러시(`flush()`)** 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 역할을 한다.

플러시가 실행되면 다음과 같은 일이 순서대로 일어난다.

1.  **변경 감지(Dirty Checking)** 가 동작하여 영속성 컨텍스트의 모든 엔티티를 스냅샷과 비교한다. 수정된 엔티티가 있다면 수정 쿼리(UPDATE SQL)를 만들어 쓰기 지연 SQL 저장소에 등록한다.
2.  **쓰기 지연 SQL 저장소**의 쿼리를 데이터베이스에 전송한다 (INSERT, UPDATE, DELETE 쿼리).

---

### 영속성 컨텍스트를 플러시하는 3가지 방법

1.  `em.flush()` 직접 호출
2.  트랜잭션 커밋 시 자동 호출
3.  JPQL 쿼리 실행 시 자동 호출

#### 1. 직접 호출

엔티티 매니저의 `flush()` 메소드를 직접 호출하여 영속성 컨텍스트를 강제로 플러시할 수 있다.
```java
em.flush(); // 직접 호출
```
> 테스트나 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고는 거의 사용하지 않는다.

#### 2. 트랜잭션 커밋 시 플러시 자동 호출

데이터베이스에 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면, 어떤 데이터도 데이터베이스에 반영되지 않는다. 따라서 트랜잭션을 커밋하기 전에는 반드시 플러시를 호출하여 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영해야 한다.

JPA는 이러한 실수를 방지하기 위해 **트랜잭션을 커밋할 때 플러시를 자동으로 호출**한다.

#### 3. JPQL 쿼리 실행 시 플러시 자동 호출

JPQL이나 Criteria(10장에서 설명) 같은 객체지향 쿼리를 호출할 때도 플러시가 자동으로 실행된다.

그 이유는 아래 예제와 같다.

> ##### 예제 3.6 JPQL 쿼리 실행 코드
>
> ```java
> em.persist(memberA);
> em.persist(memberB);
> em.persist(memberC);
>
> // 중간에 JPQL 실행
> // 이 시점에 플러시가 자동으로 호출된다.
> query = em.createQuery("select m from Member m", Member.class);
> List<Member> members = query.getResultList();
> ```
>
> `em.persist()`를 통해 `memberA`, `memberB`, `memberC`는 영속 상태가 되었지만, 아직 데이터베이스에 저장되지는 않았다.
>
> 이때 JPQL을 실행하면 SQL로 변환되어 데이터베이스에서 엔티티를 조회하는데, 만약 플러시가 호출되지 않는다면 `memberA`, `memberB`, `memberC`는 데이터베이스에 없으므로 조회 결과에 포함되지 않는다.
>
> JPA는 이러한 문제를 방지하기 위해 **JPQL을 실행하기 직전에 플러시를 자동으로 호출**하여 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 그 결과, `memberA`, `memberB`, `memberC`도 쿼리 결과에 정상적으로 포함된다.

> **참고**
>
> 식별자를 기준으로 조회하는 `find()` 메소드를 호출할 때는 플러시가 자동 호출되지 않는다.

---

### 3.5.1 플러시 모드 옵션

엔티티 매니저에 플러시 모드를 직접 설정하려면 `javax.persistence.FlushModeType`을 사용한다.

-   **`FlushModeType.AUTO`**: 커밋이나 쿼리를 실행할 때 플러시 (기본값)
-   **`FlushModeType.COMMIT`**: 커밋할 때만 플러시

```java
// 플러시 모드 직접 설정
em.setFlushMode(FlushModeType.COMMIT);
```
대부분 기본 설정인 `AUTO`를 그대로 사용한다. `COMMIT` 모드는 성능 최적화가 필요할 때 사용할 수 있다. (자세한 내용은 10.6절)

> **중요**
>
> **플러시(flush)** 라는 이름 때문에 영속성 컨텍스트에 보관된 엔티티를 **지운다고 오해하면 안 된다.**
>
> 플러시는 **영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화**하는 작업이다. 데이터베이스와의 동기화를 최대한 늦출 수 있는 이유는 **트랜잭션**이라는 작업 단위가 있기 때문이며, 트랜잭션 커밋 직전에만 동기화해주면 데이터 정합성에 문제가 없다.